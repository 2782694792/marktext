# HTTP

- [HTTP 概述 - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/web/http/overview)；

- 一种能够获取如 HTML 这样的网络资源的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)(通讯协议)；

- 是在 Web 上进行数据交换的基础，是一种 client-server 协议；

- 被设计于 20 世纪 90 年代初期，是一种可扩展的协议；

- 是应用层的协议，通过 [TCP](https://developer.mozilla.org/zh-CN/docs/Glossary/TCP)，或者是 [TLS](https://developer.mozilla.org/zh-CN/docs/Glossary/TLS)——加密的 TCP 连接来发送，理论上任何可靠的传输协议都可以使用；

- 不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如 HTML 表单这样的信息，还可以根据网页需求，仅获取部分 Web 文档内容更新网页。

## 发展

[HTTP 的发展 - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)

## 基于 HTTP 的组件系统

在请求与响应之间，还有许许多多的被称为[代理](https://developer.mozilla.org/zh-CN/docs/Glossary/Proxy_server)的实体，他们的作用与表现各不相同，比如有些是网关，还有些是 [cache](https://developer.mozilla.org/zh-CN/docs/Glossary/Cache) 等。

<img src="file:///E:/MarkText/image%20cache/基于%20HTTP%20的组件系统.png" title="" alt="" data-align="center">

### 代理（Proxy）

1. 在浏览器和服务器之间，有许多计算机和其他设备转发了 HTTP 消息。由于 Web 栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，还有一部分是表现在应用层上的，被称为**代理**（Proxy）；

2. 代理既可以表现得透明，又可以不透明（“改变请求”会通过它们）；

3. 代理主要有如下几种作用：
- 缓存（可以公开也可以是私有的，像浏览器的缓存）；

- 过滤（像反病毒扫描，家长控制...）；

- 负载均衡（让多个服务器服务不同的请求）；

- 认证（对不同资源进行权限管理）；

- 日志记录（允许存储历史信息）。

## 基本性质

- 简单；虽然下一代 HTTP/2 协议将 HTTP 消息封装到了**帧**（frame）中，HTTP 大体上还是被设计得简单易读。HTTP 报文能够被人读懂，还允许简单测试；

- 可扩展；在 HTTP/1.0 中出现的 [HTTP 标头（header）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)让协议扩展变得非常容易。只要服务端和客户端就新标头达成语义一致，新功能就可以被轻松加入进来。

- 无状态，有会话的；HTTP 是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。
  
  > 而使用 HTTP 的标头扩展，HTTP Cookie 就可以解决这个问题。把 Cookie 添加到标头中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。

- HTTP 和 连接：
  
  - HTTP 依赖于面向连接的 TCP 进行消息传递，但连接并不是必须的；
  
  - 在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）；
  
  - HTTP/1.1 引入了流水线（被证明难以实现）和持久连接的概念：底层的 TCP 连接可以通过 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 标头来被部分控制。HTTP/2 则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接；
  
  - Google 就研发了一种以 UDP 为基础，能提供更可靠更高效的传输协议 [QUIC](https://en.wikipedia.org/wiki/QUIC)。

## 控制内容

- `缓存`。

- `开放同源限制`。浏览器强制对 web 网站做了分割限制：只有来源相同的网页才能获取网站的全部信息；HTTP 通过修改标头可以开放这样的限制；

- `认证`。仅让特定游湖进行访问；

- `代理和隧道`。一般情况下，服务器和/或客户端是处于内网的，HTTP 请求就要通过代理越过这个网络屏障，并非所有代理都是 HTTP 代理；

- `会话`。使用 HTTP Cookie 允许客户端用一个服务端的状态发起请求，创建会话。

# HTTP 流

客户端进行和服务端或中间代理进行信息交互时，有以下过程：

1. 打开 TCP 连接；

2. 发送 HTTP 报文：
   
   > HTTP 报文（在 HTTP/2 之前）是语义可读的。
   > 
   > 在 HTTP/2 中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。

3. 读取服务端返回的报文信息；

4. 关闭连接或者为后续请求重用连接。

# HTTP 报文

- HTTP/1.1 以及更早的 HTTP 协议报文都是语义可读的；

- 在 HTTP/2 中，这些报文被嵌入到了一个新的二进制结构，帧；

> 帧允许实现很多优化，比如报文标头的压缩以及多路复用。

- 即使只有原始 HTTP 报文的一部分以 HTTP/2 发送出来，每条报文的语义依旧不变，客户端会重组原始 HTTP/1.1 请求。因此用 HTTP/1.1 格式来理解 HTTP/2 报文仍旧有效；

- 报文有两种类型：请求与响应。

## 请求

示例报文：

<img src="file:///E:/MarkText/image%20cache/HTTP%20请求报文.png" title="" alt="" data-align="center">

- 一个 HTTP 的请求[方法](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)，通常客户端的操作都是**获取资源（GET** 方法）或者**发送 [HTML 表单](https://developer.mozilla.org/zh-CN/docs/Learn/Forms)（POST** 方法）；

- 获取的资源的路径 URL，它没有 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)（`http://`），[domain](https://developer.mozilla.org/zh-CN/docs/Glossary/Domain)（`developer.mozilla.org`），或是 TCP 的 [port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port "Currently only available in English (US)")（HTTP 一般在 80 端口）；

- HTTP 协议版本号；

- 为服务端表达其他信息的可选[标头](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)；

- 对于一些像 POST 的方法，报文的主体（body）就包含了发送的资源，这与响应报文的主体类似。

## 响应

示例报文：

<img src="file:///E:/MarkText/image%20cache/HTTP%20响应报文.png" title="" alt="" data-align="center">

- HTTP 协议版本号；

- 状态码（[状态码（status code）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)），告知对应请求成功或失败，以及失败原因；

- 状态信息，是非权威的状态码描述信息，可以由服务端自行设定；

- HTTP [标头](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)，与请求标头类似；

- 可选项，比起请求报文，响应报文中更常见地包含获取资源的主体。
