https://zhuanlan.zhihu.com/p/560349203



## 实现步骤

1. `定义插件接口`

2. `编写插件功能`

3. `加载插件`

4. `初始化插件`

5. `注册插件`：**插件指针**添加到主程序的**插件管理器**中；

6. `运行插件`：通过插件管理器中的接口调用插件的函数；

7. `卸载插件`：从插件管理器中卸载插件，并释放所占用的内存资源。

## 装载库 API

- #include <dlfcn.h>

- **dlopen** 打开一个新库并装入内存；

- **dlsym**：在打开的动态库中查找符号的值；

- **dlclose**：关闭动态库；

- **dlerror**：返回一个描述最后一次调用 dlopen、dlsym 或 dlclose 的错误信息字符串；

- `glibc` 增加了两个 POSIX 标准中没有的API：
  
  - `dladdr`，从函数指针解析**符号名称和所在的文件**。
  
  - `dlvsym`，与 dlsym 类似，只是多了一个**版本字符串参数**。

> 使用动态链接的应用程序需要和库 `libdl.so` 一起链接，使用选项 `-ldl`。

### dlopen

- 打开一个新库，并装入内存；

- 主要用来加载库中的符号。使得在系统中添加或者删除一个模块时，都不需要重新进行编译。

```cpp
void *dlopen(const char *filename, int flag);
```

- filename : 动态库 so 文件；

- flag : 标志，指明是否立刻计算库的依赖性，通过 “|” 进行标志组合：
  
  - `RTLD_NOW` ：**立刻**计算，在 dlopen 返回前，**解析出所有未定义符号**，如果解析不出来，在 dlopen 会返回 NULL；
  
  - `RTLD_LAZY` ：**需要的时候**计算，在 dlopen 返回前，对于动态库中的**未定义的符号不执行解析**（只对函数引用有效，对于变量引用总是立即解析）；
  
  - `RTLD_GLOBAL` ：动态库中**定义的符号可被**其后打开的其它库**重定位**；
  
  - `RTLD_LOCAL` ：与 RTLD_GLOBAL 作用相反，动态库中定义的符号**不能被**其后打开的其它库**重定位**。如果没有指明是 RTLD_GLOBAL 还是 RTLD_LOCAL，则**缺省为 RTLD_LOCAL**。





### dlsym

- 加载符号地址，在打开的动态库中查找符号的值；

- 从共享库（动态库）中获取符号（全局变量与函数符号）地址；

- 通常用于获取函数符号地址，可用于对共享库中函数的包装；

```cpp
void *dlsym(void *handle, const char *symbol);
```



### dlclose

- 关闭动态库。

```cpp
int dlclose(void *handle);
```

### dlerror

- 返回一个描述最后一次调用dlopen、dlsym，或dlclose的错误信息的字符串

```cpp
char *dlerror(void);
```
