# GoogleTest

[googletest: GoogleTest - Google Testing and Mocking Framework](https://github.com/google/googletest)

googletest 是一个由 Google 的测试技术团队开发的测试框架，它考虑到了谷歌的特定需求和限制。无论你使用的是 Linux、Windows 还是 Mac，只要你编写 C++ 代码，googletest 都可以帮到你。它支持任何类型的测试，不只是单元测试。

1. 独立的且可重复的（googletest 通过在不同的对象上运行每个测试用例来隔离测试。当测试失败时允许你单独运行它，以便快速调试）；

2. 可移植的且可复用的（googletest 适用于不同的操作系统，不同的编译器）；

3. 失败时，提供尽可能多的关于故障的信息（googletest 不会在第一个测试失败时停止。相反，它仅停止当前的测试并继续运行下一个）；

4. 得到良好的组织并反映测试代码的结构（googletest 将相关的测试分组为测试套件，它们可以共享数据和子例程）；

5. 测试框架将精力集中在测试内容上（googletest 自动追踪所有定义的测试，且无需用户以运行它们的顺序迭代它们）；

6. 快（通过 googletest，可以跨测试用例复用共享资源，且只支付一次 set-up/tear-down 的开销，不使测试相互依赖）。

> 任何可被送给 `ostream` 的都可以被送进断言的宏。

## 编译

gtest 提供了两种编译方式 bazel 和 cmake，以 cmake 为例：

```shell
mkdir build
cd build 
cmake ..
# 只需要包含头文件 gtest.h或者gmock.h
```

## 断言

`断言是 gtest 核心组成，所有的测试用例最终都是以断言实现的。`

- ASSERT 系列的断言如果失败，则会产生一个严重错误并导致当前作用范围的测试用例中断；

- EXPECT 不会产生任何错误，测试用例依旧可以继续执行。

### true / false 条件测试

| 致命                       | 非致命                      | 验证               |
| ------------------------ | ------------------------ | ---------------- |
| ASSERT_TRUE(condition);  | EXPECT_TRUE(condition);  | condition: true  |
| ASSERT_FALSE(condition); | EXPECT_FALSE(condition); | condition: false |

> 失败时，`ASSERT_*` 产生一个致命错误，并从当前函数退出，`EXPECT_*` 则产生一个非致命错误，并允许函数继续运行。

### 二元比较

| 致命断言                     | 非致命断言                    | 验证             |
| ------------------------ | ------------------------ | -------------- |
| `ASSERT_EQ(val1, val2);` | `EXPECT_EQ(val1, val2);` | `val1 == val2` |
| `ASSERT_NE(val1, val2);` | `EXPECT_NE(val1, val2);` | `val1 != val2` |
| `ASSERT_LT(val1, val2);` | `EXPECT_LT(val1, val2);` | `val1 < val2`  |
| `ASSERT_LE(val1, val2);` | `EXPECT_LE(val1, val2);` | `val1 <= val2` |
| `ASSERT_GT(val1, val2);` | `EXPECT_GT(val1, val2);` | `val1 > val2`  |
| `ASSERT_GE(val1, val2);` | `EXPECT_GE(val1, val2);` | `val1 >= val2` |

> - **比较 C 字符串**，ASSERT_EQ 测试它们是否位于相同内存位置，而不是是否具有相同的值。因此，比较 C 字符串的值使用 `ASSERT_STREQ()`；
> 
> - 当执行**指针比较**时使用 `*_EQ(ptr, nullptr)` 和 `*_NE(ptr, nullptr)` 而不是 `*_EQ(ptr, NULL)` 和 `*_NE(ptr, NULL)`。

### 字符串比较

| 致命断言                          | 非致命断言                         | 验证        |
| ----------------------------- | ----------------------------- | --------- |
| ASSERT_STREQ(str1, str2);     | EXPECT_STREQ(str1, str2);     | 具有相同内容    |
| ASSERT_STRNE(str1, str2);     | EXPECT_STRNE(str1, str2);     | 具有不同内容    |
| ASSERT_STRCASEEQ(str1, str2); | EXPECT_STRCASEEQ(str1, str2); | 相同内容忽略大小写 |
| ASSERT_STRCASENE(str1, str2); | EXPECT_STRCASENE(str1, str2); | 不同内容忽略大小写 |

> 如果宽字符串（`wchar_t*`， Windows 上 `UNICODE` 模式的 `TCHAR*`，或 `std::wstring`）被送进断言，它将在打印时被转换为 UTF-8。

### 断言扩展

`SUCCEED()` : 产生一个成功标识，只代表某一个步躁成功；
`FAIL()` : 产生一个严重错误，相当于一个 ASSERT 宏失败；
`ASSERT_THROW(expre,type)` : 断言表达式 expre 会抛出一个 type 类型异常；
`ASSERTANY THROW(expre)` : 断言表达式 expre 会抛出一个任意类型异常；
`ASSERT_NO_THROW(expre)` : 断言表达式 expre 不会抛出任何异常。

## 简单测试

- 使用 `TEST()` 宏定义并命名一个测试函数（没有返回值）。

```cpp
// 1. TestSuiteName 测试套件名
// 2. TestName 测试用例名
/// 名称不该包含下划线
TEST(TestSuiteName, TestName) {
  ... test body ...
}


TEST(FactorialTest, HandlesZeroInput) {
  EXPECT_EQ(Factorial(0), 1);
}
TEST(FactorialTest, HandlesPositiveInput) {
  EXPECT_EQ(Factorial(1), 1);
  EXPECT_EQ(Factorial(8), 40320);
}
```

> [Google C++ Style Guide 函数和类命名规则](https://google.github.io/styleguide/cppguide.html#Function_Names)

## 测试夹具

- 允许你为多个不同的测试复用相同的数据对象配置。

> googletest **不** 为多个测试复用相同的测试夹具.

### 创建

1. 创建一个公有继承自 `::testing::Test` ，进行 `protected:` 类内部声明；

2. 编写一个默认的构造函数或 `SetUp()` 函数为每个测试准备对象；

3. 编写一个析构函数或 `TearDown()` 函数释放 `SetUp()` 中分配的资源；

4. 完善类资源信息，使用 TEST_F 宏，第一个参数填写新鞋新建夹具类名称。

> 建议优先使用构造/析构函数完成数据的初始化，由于C++语法不允许在构造/析构函数中调用虚函数 **SetUp/TearDown**。

### 使用

- 使用 `TEST_F()` 而不是 `TEST()`：

```cpp
// TestFixtureName 测试夹具类名（_F：fixture）
TEST_F(TestFixtureName, TestName) {
  ... test body ...
}
```

> 通过 `TEST_F()` 定义的每个测试，googletest 将在运行时创建一个 *全新的* 测试夹具，立即通过 `SetUp()` 初始化它，运行测试，通过调用 `TearDown()` 清理资源，然后删除测试夹具。

#### 具体类定义

```cpp
template <typename E>  // E is the element type.
class Queue {
 public:
  Queue();
  void Enqueue(const E& element);
  E* Dequeue();  // Returns NULL if the queue is empty.
  size_t size() const;
  ...
};
```

#### 夹具类定义

```cpp
class QueueTest : public ::testing::Test {
 protected:
  void SetUp() override {
     q1_.Enqueue(1);
     q2_.Enqueue(2);
     q2_.Enqueue(3);
  }

  // void TearDown() override {}

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};
```

#### 测试定义

```cpp
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
  int* n = q0_.Dequeue();
  EXPECT_EQ(n, nullptr);

  n = q1_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 1);
  EXPECT_EQ(q1_.size(), 0);
  delete n;

  n = q2_.Dequeue();
  ASSERT_NE(n, nullptr);
  EXPECT_EQ(*n, 2);
  EXPECT_EQ(q2_.size(), 1);
  delete n;
}
```

#### 测试调用

> 定义测试后，通过 `RUN_ALL_TESTS()` 运行它们，如果所有测试都成功,返回 `0`，否则返回 `1`。

调用 `RUN_ALL_TESTS()` 宏时：

1. 保存所有 googletest 标记的状态；

2. 为第一个测试创建一个测试夹具对象；

3. 通过 `SetUp()` 初始化；

4. 在测试夹具对象上运行测试；

5. 通过 `TearDown()` 清理测试夹具；

6. 删除夹具，恢复所有的 googletest 标记的状态；

7. 为下一个测试重复上述步骤。

```cpp
#include "gtest/gtest.h" 

int main(int argc, char **argv) {
  // 解析 googletest 标记的命令行参数，并移除所有已识别的标记
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
```

> 调用 `RUN_ALL_TESTS()` **一次**，多次调用将产生冲突。
