## Mutex

- 互斥量，C11 中与 Mutex 相关的类与函数都声明在 `mutex` 头文件中；

- std::mutex 对象提供了**独占所有权**的特性（阻塞） —— 即**不支持递归**地对 std::mutex 对象上锁，而 **std::recursive_lock 则可以递归地对互斥量对象上锁**；
  
  - 注意 lock( ) 与 unlock( ) 的加锁临界区的范围，过大会降低程序运行效率，过小不能满足对程序的控制；
  - 加锁之后要及时解锁，否则会造成死锁，**lock( ) 与 unlock( )** 成对出现。

- 互斥量是一个可以处于两态之一的变量：**解锁**和**加锁**；需要一个二进制位表示它，但常常用一个整形，0 表示解锁，其他值表示加锁。

> 互斥量使用的两个过程：
> 
> 1. 当一个线程（或进程）需要访问临界资源的临界区时，它调用 mutex_lock 。
> 
> 2. 如果该互斥量当前是解锁的（临界区可用），则调用成功，调用线程可以自由进入该临界区。

### 成员类

#### 1、Mutex 系列类

- std::**mutex**，最基本的 Mutex 类。

- std::**recursive_mutex**，**递归** Mutex 类。

- std::**time_mutex**，**定时** Mutex 类。

- std::**recursive_timed_mutex**，**定时递归** Mutex 类。

#### 2、Lock 类

- std::**lock_guard**，与 Mutex RAII 相关，方便线程对互斥量上锁。

- std::**unique_lock**，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。

#### 3、成员函数

- 构造函数：std::mutex 不允许拷贝构造、move 拷贝，最初产生的对象处于 unlocked 状态；

- std::try_lock，尝试同时对多个互斥量上锁，若：
  
  - 当前互斥量没有被其他线程占用则锁住互斥量，直到调用 unlock( ) 释放互斥量；
  
  - 当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉；
  
  - 当前互斥量被其他线程锁住，则会产生死锁。

- std::lock，可以同时对多个互斥量上锁，若：
  
  - 互斥量当前没有被锁住则调用线程将其锁住，直至调用 unlock 之前，该线程一直拥有该锁；
  
  - 互斥量被其他线程锁住，则当前的调用线程被阻塞住；
  
  - 当前互斥量被当前线程锁住，则会产生死锁。

- std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。

#### 4、std::lock_guard

为了防止我们在使用mutex的过程中意外忘记 unlock( )，引入了 std::lock_guard 的类模板，有了该类模板，我们就无需自己去控制对互斥量的加锁与解锁。
