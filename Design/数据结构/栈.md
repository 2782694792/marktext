# Stack

- **只能在一端进行插入或删除操作**的**线性表**；
- 栈顶 Top：插入或删除操作的一端，有一个栈顶指针表示；
- 栈底 Bottom：栈顶的另一端，固定不变；
- 操作特性：FILO，先进后出，LIFO，**后进先出**；
- 存储结构：**顺序栈、链式栈**；
- 对于非连续的输入输出，**出栈序列中每一个元素后面所有比他小的元素组成一个递减序列**；

## 操作

1. **Init**(&S)：初始化空栈 S；
2. **IsEmpty**(S)：判断一个栈是否为空；
3. **Push**(&S，x)：进栈，若栈未满，则将 x 加入使成为新栈顶；
4. **Pop(&S，&x)**：出栈，若栈非空，则将栈顶元素删除，并用 x 返回；
5. **GetTop**(S，&x)：栈顶元素，若栈顶元素非空，则用 x 返回；
6. Destroy(&S)：销毁，释放栈 S。

## 存储结构

### 1. 顺序栈

- 利用一组**地址连续的存储单元存放**自栈底到栈顶的数据元素；

- 栈顶指针 top：指示当前栈顶的位置；

- **上溢**（overflow）：满栈后压入元素；**下溢**（overflow）：空栈后取出元素；

- 结构体描述：

  ```cpp
  #define MAXSIZE 100         //栈中元素的最大个数
  typedef struct {
      ElemType data[MAXSIZE]; //存放栈中元素
      int top;                //栈顶指针
  } SqStack；
  ```

  1. 栈顶指针：S.top，初始化 S.top = -1；栈顶元素：S.data[S.top]；
  2. 进栈：未满时，栈指针加 1，再置为栈顶；
  3. 出栈：非空时，删除栈顶元素值，栈顶指针减 1；
  4. 空栈：S.top == -1；
  5. 满栈：S.top == MAXSIZE - 1；
  6. 大小：S.top + 1；

![](E:\MarkText\image cache\顺序栈.png)

### 2. 共享栈

- **两个顺序栈共享一个一维数组**空间；
- 两个栈的**栈底在共享空间的两端**，两个**栈顶延伸**共享空间内容；
- 栈 0 为空：Top0 = -1；栈 1 为空：Top1 = Maxsize；
- 栈 0 进栈时，Top0 ++；栈 1 入栈时，Top2--；出栈则相反；
- 栈满时：Top1 - Top0 = 1；

![](E:\MarkText\image cache\共享栈.png)

1. Top1 = Top0，还有一个共用空间；
2. Top0 > Top1，无共用空间，均满栈；
3. 当整个存储空间被占用时，才发生**上溢**；
4. 存储数据的时间复杂度：O(1)。

### 3. 链栈

- 链式存储，采用**单链表**实现，所有操作都是**在单链表的表头进行**；

  > **运算受限**的单链表。

- **无头结点**，top 指针指向栈顶元素；

- 便于多个栈共享存储空间，且**不存在栈满上溢的情况**；

- 空栈：头指针指向空，lst->next == NULL;

- 栈满：内存无限大的情况下，不存在满栈的情况；

- 插入和删除仅在栈顶处运行。

```cpp
typedef struct node
{
    ElemType data;
    struct node *next;
}LinkStackNode,*LinkStack;
```

![](E:\MarkText\image cache\链栈.png)

## 应用

### 符号匹配

1. 初始化空栈，顺序读入符号（如：左右括号匹配，读入左括号）；
2. 遇到右括号，与栈顶元素匹配（前提：栈非空）：匹配，弹出栈顶元素，并进行下一匹配；
3. 遇到左括号，入栈，确认有无满栈条件（匹配环境限制）；
4. 元素遍历结束，栈此时，若空栈则合法结束，否则序列不合法。

匹配对象：

- 起始标志和结束标志；
- 成对出现。

### 后缀（逆）波兰表达式

1. 从左至右，遍历中缀表达式的每个数字和符号；
2. 数字：输出；
3. 左括号：入栈；
4. 右括号：持续出栈，直到对应的左括号出栈为止；
5. 其他运算符号：
   1. 若优先级比栈顶元素的优先级要高（或空栈），则入栈；
   2. 若优先级较低，则栈顶出栈；
6. 运算符：同栈顶元素相同时，自身优先级较低；括号属于限定符，非直接运算符。

### 表达式运算

1. 顺序遍历表达式的每一项，对数据类型做分类压入对应栈，如：数值运算，遇到操作数则压入栈，遇到操作符，则从栈中出栈两个操作数，完成操作数的运算；
2. 将操作结果重新入栈，循环处理，直至栈顶仅有最后的操作结果。