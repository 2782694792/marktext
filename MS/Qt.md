## 特点

**优点：**

1. 跨平台，几乎支持所有平台
2. 接口简单，文档详细
3. 开发效率高

**缺点：** Qt 作为一个软件平台，比较庞大、臃肿。

## 核心机制

### 1. 元对象系统

- meta-object：提供了用于内部对象通讯的信号与槽（signals & slots）机制，运行时类型信息，以及动态属性系统（dynamic property system）；

#### 如何使用

1. **继承 QObject**：QObject 类为所有对象提供了一个基类；
2. **定义 Q_OBJECT 宏**：声明类时，将 Q_OBJECT 宏放置于类的私有区域就可以在类中使能元对象特性；
3. **使用元对象编译器**：（Meta-Object Compiler，缩写 **moc**），为每个QObject的子类提供必要的代码去实现元对象特性；

> - moc 工具读取 C++ 源文件是，若找到一个或多个包含 Q_OBJECT 宏的类声明时，会生成另一个 C++ 源文件，其中包含每个类的元对象代码；
> - 生成的源文件会被包含到类的源文件中（#include），或者编译并链接到类的实现中；

### 2. 属性系统

- 不依赖非标准的编译器特性；
- 基于元对象系统，提供信号与槽机制用于对象间通讯；
- 完善成员变量没有读写权限控制的机制，可指定读或写，包括读写后的任何预处理；

### 3. 信号与槽机制

- 用于对象之间的通讯；
- 属于 Qt 的核心特性，代替了回调机制；
- Qt 的控件预定义了多种信号，信号将在特定的时间出现时发出；槽是在响应特定信号时会被调用的方法；

#### 机制原理

1. **moc 查找**头文件中的 signal、slots，并**标记出信号、槽**；
2. 将信号、槽信息**存储到类静态变量 staticMetaObject** 中，顺序存放、**建立索引**；
3. 当发现**有 connect 连接时**，将信号、槽的**索引信息存储到 map 中**进行关联；
4. 当**调用 emit 时**，调用信号函数，并**传递**发送信号的对象指针、元对象指针、信号索引、参数列表**到 active 函数**；
5. 通过 active 函数**找到 map 中**与之**对应的槽索引**；
6. 根据槽索引找到槽函数并执行。

#### 特点

优点：

1. 类型安全：关联的信号与槽的签名必须是等同的；
2. 松散耦合：减弱对象的耦合度，信号与槽分离，无需关心去向与否；
3. 多对多：一个（多个）信号可以关联多个（一个）槽；

缺点：速度慢：同回调函数相比，调用速度慢（需要定位信号接收对象；遍历所有槽；编组、解组传递参数；多线程时信号排队）

#### 比较函数指针

1. 回调函数使用函数指针实现。若多个类关注一个类的动态变化，需要进行列表维护，管理类之间的关系，编码灵活性降低，冗余；
2. 类只需要清楚本身的信号与槽的数量并进行连接，而调用关系由 Qt 处理，灵活性高；

#### 应用

- **跨线程处理**：若一个信号和多个槽相连时，**执行顺序是不确定的**；
- 一个信号（发出）**连接到另外的一个信号**（发出）；
- 槽可以取消链接，**disconnect() 主动取消链接**（**对象 delete 之后**，Qt **自动取消**所有连接到该对象的槽）；
- Qt5 支持 Lambda 表达式；

#### 注意点

##### 信号

1. 所有的信号声明都是**公有**的，不能在 signals 前面加 public, private, protected；
2. 所有的信号都**没有返回值 void**；
3. 所有的信号都**不需要定义**；
4. 必须直接或间接**继承自 QOBject 类**，并且开头**私有声明包含 Q_OBJECT**；
5. 在同线程中，当一个信号（链接了多个槽）被 emit 发出时，会立即执行其（所有的）槽函数，等槽函数执行完毕后，才会执行 emit 后面的代码。不同线程中（即跨线程时），槽函数的执行顺序是随机的；
6. 在链接信号和槽时，可以设置链接方式为：在发出信号后，不需要等待槽函数执行完，而是直接执行后面的代码，是通过 connect 的第 5 个参数（连接方式）；
7. 信号和槽的参数类型一致（信号的参数可以比槽函数的参数多）。

##### 槽

1. 宏定义不能用在 signal 和 slot 的参数中；
2. 构造函数不能用在 signals 或者 slots 声明区域内；
3. **不能有函数指针参数**；
4. **不能有缺省参数**；
5. **不能携带模板类参数**；
6. 避免无限循环；
7. 如果一个信号与多个槽相关联时，当信号被发出，与之相关的槽被激活的顺序是随机的（链接时的顺序执行的）；

## 事件过滤器

1. **父窗口类通过重写 evenFilter 方法**来监听子控件的相关事件；对于安装了事件过滤器的对象，其所有时间都会经过该事件过滤器，直接由父窗口进行监测；

   > 不需要通过重写控件的方法获取对应的事件；

2. 专门的事件过滤器，**对特定的对象/事件进行处理**；

   > 只对安装的对象进行处理，不关心其它，且可被多个对象使用；

3. **全局事件监听**：给 **QApplication** 安装事件过滤器；

   > 在 notify 方法下发事件时，QApplication 对象可以拿到第一控制权；

### 特点

1. 若过滤器返回 true，则**事件过滤，不会发送到对象本身**。如果返回 false 则不做任何处理，有 event() 方法将事件分发给原有的对象，否则返回父类的 evenFilter 方法；
2. **一个对象可以安装多个事件过滤器**（对象事件可被多个对象进行监控/处理/过滤），且最**先安装的最后被调用**；
3. 一个事件过滤器被多个对象安装时，若 evenFilter 方法中删除了对象，则必须返回 true，避免程序崩溃；

## connect 连接方式

1. Qt::AutoConnection：

   **默认值，连接类型由信号发送时决定**。如果接收者和发送者在同一线程，则自动使用 Qt::DirectConnection 类型，否则自动使用 Qt::QueuedConnection 类型。

2. Qt::DirectConnection：

   槽函数在信号发送时**直接被调用**，槽函数和信号发送者在**同一线程**，同步执行。emit 语句后面的代码将在所有槽函数执行完毕后才被执行；

3. Qt::QueuedConnection：

   信号发出后，**信号会暂时被放到一个消息队列中**，需**等待接收对象**所属线程的事件循环取得控制权时才取得该信号，然后执行和信号关联的槽函数。**既可以同一线程传递消息，也可以跨线程操作**。 emit 语句后的代码将在发出信号后立即被执行，无需等待槽函数执行完毕；

4. Qt::BlockingQueuedConnection：

   与 Qt::QueuedConnection 一致，不过发送完信号后**发送者所在线程会阻塞，直到槽函数运行完毕**。而且接收者和发送者绝对**不能在同一个线程**，否则程序会**死锁；

5. Qt::UniqueConnection：

   可以通过按位或（|）与以上四个结合一起使用。当这个 flag 设置时，当某个信号和槽已经连接时，就**不能进行重复连接**。

## 事件与信号

1. 使用**场合和时机不同**：如使用 QPushButton 时，更关注 clicked 信号，而很少关心促成该信号的底层鼠标或键盘事件；
2. 使用的**机制和原理不同**：事件类似 Windows 里的消息，一般是窗口系统发出，且会被放到事件队列中，支持异步和同步的通信机制，属于非阻塞的；而信号一般是由对象发出，不支持异步调用；

## Qt 多线程

- **QtConcurrent** 运行一个线程池，但不适合运行大量的阻塞操作；如果有很多阻塞操作，很快就会耗尽池并让其他请求排队。在这种情况下，**QThread**(较低级别的构造)可能更适合于操作(每个代表一个线程)；
- 互斥量（**QMutex**，手动加解锁）、互斥锁（**QMutexLocker**，构造加锁、析构解锁）；
- 条件变量（**QWaitCondition**）：wait(&m_muxtex, time); wakeAll();
- 读写锁（**QreadWriteLock**）：适合多次对共享数据进行读操作的阅读线程，同时进行资源访问，而写入时阻塞读操作（写独占）；
- 读锁（**QReadLocker**）：简化 QreadWriteLock 中读操作的上锁和解锁，QReadLocker(QReadWriteLock \*)；
- 写锁（**QWriteLocker**）：简化读写锁中写操作的上锁和解锁，QWriteLocker(QReadWriteLock *)；
- 信号量（**QSemaphore**）：计数信号量，可以获取多次，实现在同一时间被多个线程访问，通常用于保护一定数量的相同资源；使用：生产者/消费者模式；

## 内存管理机制

1. 所有继承自 **QOBJECT** 类的类，会一级一级的在最上面的父类 delete 时被 delete；
2. 主动 delete 一个 QOBJECT 时，建议使用 **deleteLater**() 函数，它会让所有时间都发送完，处理好后清理这块内存；
3. 不建议在一个 QOBJECT 的父类之外持有对 QOBJECT 的指针；
4. 智能指针 QPointer 类，所有 QOBJECT 的子类都可以用这个进行包装，当其引用的对象被销毁时会**自动指向 NULL**，避免野指针，也无需担心多次 delete；