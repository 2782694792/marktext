## gcc、g++

- gcc 和 g++ 都是 GNU 的一个**编译器**；
- 对 **.c 文件**则以 **C 语言**代码对待，对 **.cpp 文件**则以 **C++ 代码**对待；
- 编译阶段，**g++ 会调用 gcc**，对于 C++ 代码，两者都是等价的，但是因为 **gcc 命令不能自动和 C++ 程序使用的库连接**，所以通常用 g++ 来完成链接；
- 链接时可以用 **g++** 或 **gcc -lstdc++**；

## gcc 编译

- 可以用来编译C/C++、FORTRAN、JAVA、OBJC、ADA等语言的程序

### 语法

```sh
gcc [选项] [参数]
```

### 预处理

- **处理源文件和头文件中以 # 开头的命令，并删除程序中的注释**
- 选项：**-E**

- ```sh
  gcc -E hello.c -o hello.i
  ```

- 作用：将 hello.c 预处理输出 hello.i 文件

- 附加：

  | 选项                    | 作用                                                         |
  | ----------------------- | ------------------------------------------------------------ |
  | -D name[=definition]    | 定义宏 name，搭配源代码中的 #ifdef name 命令使用，可以实现条件式编译。 |
  | -U name                 | 若定义过宏 name，则“取消” name 的定义                        |
  | -include file           | 如同在源代码中添加 #include "file"                           |
  | -iquote dir             | 指定（以引号 #include "" 导入的）头文件的搜索路径            |
  | -I dir（GCC 10.1 弃用） | 在 -iquote 指令指定的目录下搜索（以引号 "" 和 <> 导入的）头文件失败时，再去 -l 指定的目录中查询 |

### 编译

- **在这个阶段中，gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误之后，gcc 把代码翻译成汇编语言**

- 选项：**-S**

- ```sh
  gcc -S hello.i -o hello.s
  ```

- 作用：将预处理输出文件 hello.i 会变成 hello.s 文件

- 附加：

  > - 提高文件内汇编代码的可读性，可以借助 -fverbose-asm 选项；
  >
  > 
  >
  > - 如果操作对象为 .i 文件，则 GCC 编译器只需编译此文件；
  > - 如果操作对象为 .c 或者 .cpp 源代码文件，则 GCC 编译器会对其进行预处理和编译这 2 步操作。

### 汇编

- **把编译阶段生成的 .s 文件转成二进制目标代码 .c 文件**

- 选项：**-c**

- ```sh
  gcc -c hello.s -o hello.o
  ```

- 作用：将汇编输出的 hello.s 编译出 hello.o 文件

- 附加：

  > - 如果指定文件为源程序文件（例如 demo.c），则 gcc -c 指令会对 demo.c 文件执行预处理、编译以及汇编这 3 步操作；
  > - 如果指定文件为刚刚经过预处理后的文件（例如 demo.i），则 gcc -c 指令对 demo.i 文件执行编译和汇编这 2 步操作；
  > - 如果指定文件为刚刚经过编译后的文件（例如 demo.s），则 gcc -c 指令只对 demo.s 文件执行汇编这 1 步操作；
  > - 如果指定文件已经经过汇编，或者 GCC 编译器无法识别，则 gcc -c 指令不做任何操作。

### 链接

- **编译成功后进入链接阶段**

- 选项：**-o**

- ```sh
  gcc hello.o -o hello
  ```

- 作用：将编译输出文件 hello.o 链接成最终可执行文件 hello

- 附加：

  > 1. 标准库的大部分函数通常放在文件 libc.a（“achieve”，“获取”）；
  > 2. 用于共享的动态链接文件 libc.so（“share object”，“共享对象”）；
  > 3. 把包括所需链接库的目录加到环境变量 LIBRARYPATH 中；

## 编译选项

> -o：	指定**生成输出文件**名称；
> -c：	**仅执行编译**操作，不进行链接操作；
> -lm：	m 是基本名称，选项后紧跟着的名称的基础上自动添加前缀、后缀；
>
> -E：	**仅执行预处理**，不进行编译；
> -S：	将 C 语言源代码转换为**汇编代码**；
> -Wall：显示**警告信息**；
> -O：	使用**编译优化级别**编译程序，级别越大优化越好，但编译越久；
> -L：	为 GCC 增加另一个搜索链接库的目录（-L/usr/lib）；
>
> -llibrary（-I library）：library 库文件名，用于指定链接中程序调用的库文件，-l 和 库文件名之间不使用空格；**链接库一般位于 /lib/ 或 /usr/lib/**；
> -ansi：	对 C 等价于 -std=c90，对 C++ 等价于 -std=c++98；
> -std：	手动指令编程语言所遵循的标准；	

## 链接库

- 在 Linux 发行版中，静态链接库和动态链接库通常存放在 **/usr/bin 或者 /bin** 目录下。

### 静态链接库

- 程序文件中哪里用到了库文件中的功能模块，GCC 编译器就会将该模板代码直接复制到程序文件的适当位置，最终生成可执行文件；
- 优势：生成的可执行文件**不再需要任何静态库文件**的支持就**可以独立运行**（可移植性强）；
- 劣势：如果程序文件中**多次调用**库中的同一功能模块，则该模块代码势必就会被**复制多次**，生成的可执行文件中会包含多段完全相同的代码，**造成代码的冗余**。

> 和使用动态链接库生成的**可执行文件**相比，**静态链接库生成的体积更大**。

- 在 Linux 发行版系统中，静态链接库文件的后缀名通常用 **.a** 表示；在 Windows 系统中，静态链接库文件的后缀名为 **.lib**。

### 动态链接库

- 采用动态链接库实现链接操作时，程序文件中哪里需要库文件的功能模块，GCC 编译器不会直接将该功能模块的代码拷贝到文件中，而是**将功能模块的位置信息记录到文件中**（索引），直接生成可执行文件；
- 优势：由于可执行文件中**记录的是功能模块的地址**，真正的实现代码会**在程序运行时被载入内存**，这意味着，**即便功能模块被调用多次，使用的都是同一份实现代码**；
- 劣势：**生成的可执行文件无法独立运行**，必须借助相应的库文件（**可移植性差**）。

> 生成的可执行文件的体积更小，其内部不会被复制一堆冗余的代码。

- 在 Linux 发行版系统中，动态链接库的后缀名通常用 **.so** 表示；在 Windows 系统中，动态链接库的后缀名为 **.dll**。