## 互斥量

- Mutex 又称互斥量，C11  中与 Mutex 相关的类与函数都声明在 <mutex> 头文件中；

- std::mutex 对象提供了独占所有权的特性 —— 即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁；
  
  - 时刻注意lock( ) 与 unlock( ) 的加锁临界区的范围，太大了会导致程序运行效率低下，大小了则不能满足我们对程序的控制；

- 加锁之后要及时解锁，否则会造成死锁，lock( ) 与 unlock( ) 应该是成对出现。

互斥量是一个可以处于两态之一的变量：解锁和加锁；需要一个二进制位表示它，但常常使用一个整形量，0 表示解锁，而其他所有值表示加锁。

> 互斥量使用两个过程：当一个线程（或进程）需要访问临界资源的临界区时，它调用 mutex_lock 。如果该互斥量当前是解锁的（即临界区可用），调用成功，调用线程可以自由进入该临界区。

### <mutex> 头文件介绍

#### 1、Mutex 系列类

- std::mutex，最基本的 Mutex 类。
- std::recursive_mutex，递归 Mutex 类。
- std::time_mutex，定时 Mutex 类。
- std::recursive_timed_mutex，定时递归 Mutex 类。

#### 2、Lock 类

- std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。
- std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。

#### 3、成员函数

- 构造函数：std::mutex 不允许拷贝构造、move 拷贝，最初产生的对象处于 unlocked 状态；
- std::try_lock，尝试同时对多个互斥量上锁，若：（1）当前互斥量没有被其他线程占用则锁住互斥量，直到调用 unlock( ) 释放互斥量；（2）当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉；（3）当前互斥量被其他线程锁住，则会产生死锁。
- std::lock，可以同时对多个互斥量上锁，若：（1）互斥量当前没有被锁住则调用线程将其锁住，直至调用 unlock 之前，该线程一直拥有该锁；（2）互斥量被其他线程锁住，则当前的调用线程被阻塞住；（3）当前互斥量被当前线程锁住，则会产生死锁。
- std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。

#### 4、std::lock_guard

为了防止我们在使用mutex的过程中意外忘记 unlock( )，引入了std:：lock_guard的类模板，有了该类模板，我们就无需自己去控制对互斥量的加锁与解锁。吧 
