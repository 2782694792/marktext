# 第一章 深入浅出IO流

## 1.1 没有 iostream

    当我们的程序支持输入输出流 <iostream> 的时候，我们可以这么操作来实现标准的输出：

```cpp
#include <iostream>
int main(){
    std::cout<<"Hello World"<<std::endl;
    return 0;
}
```

    此时，当我们自定义的程序，需要在本身的基础上支持自定义的打印操作的时候，这个时候没有输入输出流 <iostream> ，我们怎么处理：

> iostream 依赖于 C++ 标准库，但是有不依赖于 C++ 标准库的东西，比如 put 系列函数，该系列函数是 C 运行库提供的函数，但是此处使用 put 系列函数显得太不 C++，当然可以对其进行封装再使用 —— 面向对象编程不就是这样的吗？

    到这一步，我们可以来考虑使用类的概念来对 put 系列函数的封装，此处我们选择使用 putc，putc 函数的作用是将一个字符写进指定的文件中，这刚好满足我们的需求。

```cpp
void sendstr(FILE* fp,const char* str,int n)
    for(int i=0;i<n;++i){
        putc(*str++,fp);
    }
}

FILE* operator<<(FILE* fp,const MyString& str){
    sendstr(fp,str.c_str(),str.size());
    return fp;
}

int main(){
    MyString str = "Hello World";
    stdout<<str;
    return 0;
}
```

> stdout 是 C 语言定义的标准输出，也就是控制台，而 std::cout 是 C++ 的 ostream 的对象，目的地也是控制台，他是对 stdout 的封装。

    此时，我们再对 stdout 进行封装来完成面向对象：

```cpp
class MyStrIobase{
public:
    virtual ~MyIobase(){}
    virtual void send(const char* ptr,int n){}
};

void sendstr(MyStrIobase& strio,const char* ptr,int n){
    strio.send(ptr,n)
}

class OStream : public MyStrIobase{
public:
    virtual void send(const char* ptr,int n){
        for(int i=0;i<n;++i){
            putc(*ptr++,stdout)
        }
    }
};
```

    此时我们利用 OStream 的实例化对象来完成对输出的打印，需要完成对符号 << 的函数重载：

```cpp
template<class T>
T& operator<<(T& io,const MyString& str){
    sendstr(io,str.c_str(),str.size());
    return io;
}

OStream gOut;
int main(){
    myString str = "Hello World";
    gOut<<str;
    return 0;
}
```

    程序如同我们预期正常工作，那么，现在我们再回过头去看看我们的MyStrIobase,如果我们想要让他对文件的支持，那么我们应该怎么做呢？我们对FILE*进行简单的封装即可：

```cpp
class FileOStream : public MyStrIobase{
public:
    FileOStream(const char* fileName,const char* mode){
        mFile = fopen(fileName, mode);
    }
    virtual void send(const char* ptr, int n){
        if (mFile == nullptr)
            return;
        for (int i = 0; i < n; ++i){
            putc(*ptr++, mFile);
        }
    }
    void close(){
        fclose(mFile);
        mFile = nullptr;
    }
private:
    FILE* mFile{ nullptr };
};

int main(){
    MyString str = "Hello World";
    FileOStream out("text.txt","w+");
    out << str;
    out.close();
    return 0;
}
```

## 1.2 有 iostream

    当我们存在 iostream 时，进行以下操作来深入观察它的工作原理：

```cpp
int main(){
    std::cout << "Hello World" << std::endl;
    return 0;
}
```

    从中我们可以看到控制台打印出了字符 "Hello World" ，同时光标移动到下一行起始处，此时我们可以这么理解，其中，编译系统将 "Hello World" 放进 std::cout 中实现了打印，然后 std::endl 操作了 std::cout 进行了换行，从左到右顺序执行。

    接下来我们从符号 << 重载函数开始：

```cpp
std::ostream& operator<<(std::ostream& os,const char* msg){
    os.write(msg,strlen(msg));
    return os;
}
```

    执行后返回 std::cout ，而执行：`std::cout<<std::endl;` 并不可以解释为将 std::endl 放进 

std::cout 中，因为 std::endl 一个函数指针，类似如下：

```cpp
std::ostream& endl(std::ostrem& os){
    os<<"\n";
    os.flush();
    return os;
}
```

    那由此产生的指针又是如何与流操作符联系上的呢？解决方式有很多，这里简单举一个例子：

```cpp
typedef std::function<std::ostream&(std::ostream&)> streamoperationtype;
std::ostream& operator<<(std::ostream& os,streamoperationtype fun){
    return fun(os);
}
```

    可看出，通过 std::function 的变化将流指针通过函数转换从而对流指针进行字符重载，从而转化出流对象。

    下面是 vs 中的 iostream 声明的流对象，w 开头的是针对 unicode 字符的流对象，常用的是 cin 和 cout 以及 cerr ，而 clog 是用于输出日志的，它写的目的地和 cerr 一样都是 stderr 。

```cpp
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 istream cin, *_Ptr_cin;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream cout, *_Ptr_cout;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream cerr, *_Ptr_cerr;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream clog, *_Ptr_clog;

__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wistream wcin, *_Ptr_wcin;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream wcout, *_Ptr_wcout;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream wcerr, *_Ptr_wcerr;
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream wclog, *_Ptr_wclog;
```

    可以发现其中缺少对 char 字符的操作重载，那是因为 put 和 writte 可以简单地写出字符，从而不需要实现一个流操作符。
